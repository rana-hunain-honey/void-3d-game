{"file_contents":{"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"ursina>=7.0.0\",\n]\n","size_bytes":165},"3d app/README.md":{"content":"Red Void — Ursina prototype\r\n\r\nThis is a Python/Ursina port of the `red_void.html` three.js prototype.\r\n\r\nQuick start (Windows PowerShell):\r\n\r\n1. Create a venv and activate it:\r\n\r\n```powershell\r\npython -m venv .venv\r\n.\\.venv\\Scripts\\Activate.ps1\r\n```\r\n\r\n2. Install requirements:\r\n\r\n```powershell\r\npip install -r requirements.txt\r\n```\r\n\r\n3. Run the prototype:\r\n\r\n```powershell\r\npython main.py\r\n```\r\n\r\nControls:\r\n- WASD / Arrow keys: move\r\n- Left click / Space: shoot\r\n- P: Pre-warm Pools\r\n- T: Trim Pools\r\n\r\nNotes:\r\n- This is an initial port focusing on functionality parity: player, enemies, pools, spawn logic, particles, and settings persistence.\r\n- Audio is left as placeholders (Ursina can play WAV files if you add them and call `Audio()` in places where JS used WebAudio).\r\n","size_bytes":782},"replit.md":{"content":"# Red Void - 3D Survival Shooter\n\n## Overview\nRed Void is a 3D first-person survival shooter game built with Python and the Ursina game engine. Players navigate a neon grid environment, shooting at incoming enemies to survive as long as possible.\n\n## Project Structure\n- **3d app/main.py**: Main Python/Ursina game implementation\n- **3d app/red_void.html**: Alternative Three.js browser-based version\n- **3d app/requirements.txt**: Python dependencies (ursina)\n- **3d app/settings.json**: Game settings persistence\n- **3d app/*.wav**: Sound effects for shooting and kills\n\n## Technology Stack\n- **Language**: Python 3.11\n- **Game Engine**: Ursina (built on Panda3D)\n- **Alternative**: Three.js (HTML version)\n\n## Game Features\n- First-person shooter mechanics\n- Object pooling for performance optimization\n- Adaptive spawn system based on FPS\n- Neon grid aesthetic\n- Settings persistence (shadows, particles, sound)\n- Mouse-based aiming with pointer lock\n- Free-look mode\n\n## Controls\n- WASD / Arrow keys: Move\n- Mouse: Aim\n- Left Click / Space: Shoot\n- F: Toggle free look\n- P: Pre-warm object pools\n- T: Trim object pools\n\n## Recent Changes\n- Initial project setup on Replit (October 23, 2025)\n- Installed Python 3.11 and Ursina dependencies\n- Created .gitignore for Python projects\n\n## Notes\n- Ursina creates a desktop window and requires a display server\n- For Replit deployment, the HTML/Three.js version is more suitable for web access\n- The Python version is best for local development or environments with display support\n","size_bytes":1530},"3d app/main.py":{"content":"from ursina import *\r\nimport json\r\nimport os\r\nimport random\r\nimport math\r\nimport time as pytime\r\ntry:\r\n    import winsound\r\nexcept Exception:\r\n    winsound = None\r\nimport wave\r\nimport struct\r\n\r\n# === Configuration ===\r\nSPAWN_SEC = 3.0\r\nMAX_ENEMIES = 200\r\nENEMY_SPEED = 2.6\r\nENEMY_TURN_RATE = 180.0  # degrees per second for steering\r\nFIREBALL_SPEED = 180.0\r\nPLAYER_SPEED = 4.8\r\nPLAYER_RADIUS = 0.35\r\nWORLD_RADIUS = 30\r\nPOOL_MAX = 300\r\n\r\nSETTINGS_FILE = 'settings.json'\r\n\r\n# === Settings persistence ===\r\ndefault_settings = {\r\n    'shadows': True,\r\n    'particles': True,\r\n    'sound': True,\r\n    'spawn_multiplier': 1.0,\r\n    'enemy_speed_multiplier': 1.0,\r\n}\r\nif os.path.exists(SETTINGS_FILE):\r\n    try:\r\n        settings = json.load(open(SETTINGS_FILE))\r\n    except Exception:\r\n        settings = default_settings.copy()\r\nelse:\r\n    settings = default_settings.copy()\r\n\r\n# === App ===\r\napp = Ursina()\r\nwindow.title = 'Red Void — Ursina Prototype'\r\nwindow.borderless = False\r\nwindow.fullscreen = False\r\nwindow.color = color.black\r\n\r\n# camera\r\ncamera.fov = 70\r\ncamera.y = 2\r\n\r\n# score and UI\r\nscore = 0\r\nscore_text = Text(text=f'Kills: {score}', position=window.top_left + (0.08, -0.04), scale=2, origin=(0,0), color=color.azure)\r\nfps_text = Text(text='', position=window.top_right + (-0.26, -0.04), scale=2, origin=(0,0), color=color.green)\r\n\r\n# Pools\r\nenemy_pool = []\r\nfireball_pool = []\r\nparticles_pool = []\r\nparticles_active = []\r\n\r\nenemies = []\r\nfireballs = []\r\n\r\n# Player\r\nplayer = Entity(model='cube', color=color.light_gray, scale=(0.5,0.3,0.9), position=(0,0,0))\r\nplayer.rotation_z = 90\r\n# hide visible player model for first-person view (we keep the entity for movement)\r\nplayer.visible = False\r\n\r\n# attach camera to player to make movement first-person\r\ncamera.parent = player\r\ncamera.position = (0, 1.6, 0)\r\ncamera.rotation = (0,0,0)\r\n\r\n# base camera local position (for bobbing)\r\ncamera_base_pos = Vec3(*camera.position)\r\n\r\n# mouse sensitivity\r\nMOUSE_SENS = 60.0\r\nMOUSE_SMOOTH = 12.0\r\n\r\n# simple weapon model (first-person view)\r\nweapon = Entity(parent=camera, model='cube', color=color.dark_gray, scale=(0.12,0.06,0.36), position=(0.28,-0.18,0.6), rotation=(0,8,4))\r\n\r\n# crosshair defaults\r\ncrosshair_default_scale = 0.02\r\n\r\n# simple crosshair\r\ncrosshair = Entity(parent=camera.ui, model='quad', color=color.rgb(255,60,60), scale=(0.02,0.02), position=(0,0))\r\n\r\n# HUD indicator for mouse lock\r\nmouse_lock_text = Text(text='', position=window.bottom_right + (-0.28, 0.04), scale=1.2, color=color.azure)\r\n\r\n# neon grid: create tiled quads (cheap and simple)\r\nGRID_SIZE = 40\r\nGRID_DIVS = 20\r\ngrid_parent = Entity()\r\nline_entities = []\r\nfor i in range(GRID_DIVS+1):\r\n    t = i / GRID_DIVS * GRID_SIZE - GRID_SIZE/2\r\n    # vertical\r\n    e = Entity(parent=grid_parent, model='cube', color=color.rgb(255,40,40), scale=(0.02,0.001,GRID_SIZE), position=(t,-1.19,0))\r\n    line_entities.append(e)\r\n    # horizontal\r\n    e2 = Entity(parent=grid_parent, model='cube', color=color.rgb(255,40,40), scale=(GRID_SIZE,0.001,0.02), position=(0,-1.19,t))\r\n    line_entities.append(e2)\r\n\r\n# light flash\r\nflash_light = Entity(model='sphere', color=color.red, scale=0.1, enabled=False)\r\n\r\n# free look / mouse state\r\nfree_look = False\r\nright_mouse_look = False\r\nplayer_yaw = 0.0\r\nfree_look_indicator = Text(text='Free Look: OFF (F)', position=window.bottom_left + (0.08, 0.04), scale=1.25, color=color.azure)\r\n\r\n# FPS/adaptive spawn tracking\r\n_fps_accum = 0.0\r\n_fps_count = 0\r\n_last_fps_check = pytime.time()\r\n\r\n# audio files (generate simple beeps if missing)\r\nSHOT_WAV = 'shot.wav'\r\nKILL_WAV = 'kill.wav'\r\nshot_snd = None\r\nkill_snd = None\r\n\r\ndef generate_sine_wav(path, freq=440.0, duration=0.08, volume=0.2, samplerate=22050):\r\n    n_samples = int(samplerate * duration)\r\n    with wave.open(path, 'w') as wf:\r\n        wf.setnchannels(1)\r\n        wf.setsampwidth(2)\r\n        wf.setframerate(samplerate)\r\n        max_amp = 32767 * volume\r\n        for i in range(n_samples):\r\n            t = float(i) / samplerate\r\n            val = int(max_amp * math.sin(2.0 * math.pi * freq * t))\r\n            wf.writeframes(struct.pack('<h', val))\r\n\r\ndef ensure_audio():\r\n    global shot_snd, kill_snd\r\n    if not os.path.exists(SHOT_WAV):\r\n        generate_sine_wav(SHOT_WAV, freq=880.0, duration=0.06, volume=0.18)\r\n    if not os.path.exists(KILL_WAV):\r\n        generate_sine_wav(KILL_WAV, freq=540.0, duration=0.09, volume=0.24)\r\n    try:\r\n        shot_snd = Audio(SHOT_WAV, autoplay=False)\r\n        kill_snd = Audio(KILL_WAV, autoplay=False)\r\n    except Exception:\r\n        shot_snd = None\r\n        kill_snd = None\r\n\r\nensure_audio()\r\n\r\n\r\n# helpers\r\nclock = time\r\nspawn_interval_ms = int(max(200, SPAWN_SEC * 1000) / max(0.0001, settings.get('spawn_multiplier',1)))\r\nlast_spawn_time = 0\r\n\r\n# pooling functions\r\ndef prefill_pools():\r\n    for i in range(40):\r\n        if len(enemy_pool) < POOL_MAX:\r\n            e = Entity(model='cube', color=color.red, scale=(0.9,1.2,0.4), enabled=False)\r\n            enemy_pool.append(e)\r\n        if len(fireball_pool) < 80:\r\n            f = Entity(model='sphere', color=color.rgb(255,102,102), scale=0.18, enabled=False)\r\n            fireball_pool.append(f)\r\n        if len(particles_pool) < 80:\r\n            p = Entity(model='sphere', color=color.rgb(255,68,68), scale=0.03, enabled=False)\r\n            particles_pool.append(p)\r\n\r\ndef trim_pools():\r\n    # keep small reserve\r\n    reserve_enemies = 20\r\n    while len(enemy_pool) > reserve_enemies:\r\n        e = enemy_pool.pop()\r\n        e.disable()\r\n        destroy(e)\r\n    reserve_fire = 20\r\n    while len(fireball_pool) > reserve_fire:\r\n        f = fireball_pool.pop()\r\n        f.disable()\r\n        destroy(f)\r\n\r\n# spawn enemy\r\ndef spawn_enemy():\r\n    if len(enemies) >= MAX_ENEMIES:\r\n        return\r\n    # pick position on sphere-ish\r\n    theta = random.uniform(0, 2*pi)\r\n    phi = random.uniform(-0.6, 0.6)\r\n    x = (WORLD_RADIUS + random.uniform(0,4)) * math.cos(theta) * math.cos(phi)\r\n    z = (WORLD_RADIUS + random.uniform(0,4)) * math.sin(theta) * math.cos(phi)\r\n    y = math.sin(phi) * (WORLD_RADIUS*0.2)\r\n    if enemy_pool:\r\n        e = enemy_pool.pop()\r\n        e.position = (x, 0, z)\r\n        e.enabled = True\r\n    else:\r\n        e = Entity(model='cube', color=color.red, scale=(0.9,1.2,0.4), position=(x,0,z))\r\n    # store speed; direction recomputed each frame toward the player\r\n    speed = ENEMY_SPEED * settings.get('enemy_speed_multiplier',1.0)\r\n    enemies.append({'ent': e, 'speed': speed})\r\n    # flash\r\n    invoke(lambda: flash(0.6), delay=0)\r\n\r\n# shoot\r\ndef shoot():\r\n    # spawn from camera (screen center) so shots come from the player's view\r\n    if fireball_pool:\r\n        f = fireball_pool.pop()\r\n        f.position = camera.world_position + camera.forward * 0.6\r\n        f.enabled = True\r\n    else:\r\n        f = Entity(model='sphere', color=color.rgb(255,102,102), scale=0.18, position=camera.world_position + camera.forward * 0.6)\r\n    # velocity in forward direction of camera\r\n    forward = camera.forward\r\n    vel = forward * FIREBALL_SPEED\r\n    fireballs.append({'ent': f, 'vel': vel, 'born': time.time()})\r\n    # sound placeholder\r\n    if settings.get('sound', True):\r\n        if shot_snd:\r\n            try: shot_snd.play()\r\n            except: pass\r\n        elif winsound:\r\n            try: winsound.Beep(880, 60)\r\n            except: pass\r\n    # recoil: move weapon back and bump camera pitch slightly\r\n    weapon.position += Vec3(0,0,-0.06)\r\n    camera.rotation_x = max(-70, camera.rotation_x - 3.5)\r\n    # pulse crosshair\r\n    crosshair.scale = (crosshair.scale[0] * 0.5 + crosshair_default_scale * 3.5, crosshair.scale[1] * 0.5 + crosshair_default_scale * 3.5)\r\n\r\n# simple flash effect\r\ndef flash(intensity):\r\n    flash_light.enabled = True\r\n    flash_light.scale = intensity * 0.3\r\n    invoke(lambda: setattr(flash_light, 'enabled', False), delay=0.06)\r\n\r\n# input\r\ndef input(key):\r\n    if key == 'space' or key == 'left mouse down':\r\n        shoot()\r\n    if key == 'p':\r\n        prefill_pools()\r\n    if key == 't':\r\n        trim_pools()\r\n    if key == 'f':\r\n        global free_look\r\n        free_look = not free_look\r\n        free_look_indicator.text = 'Free Look: ' + ('ON' if free_look else 'OFF') + ' (F)'\r\n\r\n# UI buttons\r\nButton(text='Pre-warm Pools (P)', color=color.black, scale=(0.12,0.05), position=window.top_right + (-0.12, -0.06), on_click=lambda: prefill_pools())\r\nButton(text='Trim Pools (T)', color=color.black, scale=(0.12,0.05), position=window.top_right + (-0.12, -0.12), on_click=lambda: trim_pools())\r\nButton(text='Verify Pools', color=color.black, scale=(0.12,0.05), position=window.top_right + (-0.12, -0.18), on_click=lambda: verify_pools())\r\n\r\n# settings save every now and then\r\nsave_timer = 0\r\n\r\ndef update():\r\n    global last_spawn_time, score, save_timer\r\n    dt = time.dt\r\n    # snap grid to camera world x/z so the grid stays centered under player\r\n    cam_x = int(math.floor(camera.world_x / (GRID_SIZE / GRID_DIVS))) * (GRID_SIZE / GRID_DIVS)\r\n    cam_z = int(math.floor(camera.world_z / (GRID_SIZE / GRID_DIVS))) * (GRID_SIZE / GRID_DIVS)\r\n    grid_parent.x = cam_x\r\n    grid_parent.z = cam_z\r\n\r\n    # simple movement WASD (relative to camera yaw)\r\n    move_dir = Vec3(0,0,0)\r\n    yaw = camera.rotation_y\r\n    forward = Vec3(math.sin(math.radians(yaw)), 0, math.cos(math.radians(yaw)))\r\n    right = Vec3(forward.z, 0, -forward.x)\r\n    if held_keys['w'] or held_keys['up arrow']:\r\n        move_dir += forward\r\n    if held_keys['s'] or held_keys['down arrow']:\r\n        move_dir -= forward\r\n    if held_keys['a'] or held_keys['left arrow']:\r\n        move_dir -= right\r\n    if held_keys['d'] or held_keys['right arrow']:\r\n        move_dir += right\r\n    if move_dir.length_squared() > 0:\r\n        move_dir = move_dir.normalized()\r\n    player.position += move_dir * PLAYER_SPEED * dt\r\n\r\n    # camera bob when moving\r\n    move_speed = move_dir.length()\r\n    bob_x = math.sin(pytime.time() * 8.0) * 0.004 * move_speed\r\n    bob_y = math.cos(pytime.time() * 8.0) * 0.008 * move_speed\r\n    camera.position = camera_base_pos + Vec3(bob_x, bob_y, 0)\r\n    weapon.x = 0.28 + bob_x * 3.0\r\n    weapon.y = -0.18 + bob_y * 2.0\r\n    # crosshair damping towards default\r\n    crosshair.scale = (crosshair.scale[0] * 0.85 + crosshair_default_scale * 0.15, crosshair.scale[1] * 0.85 + crosshair_default_scale * 0.15)\r\n\r\n    # spawn logic\r\n    if time.time() - last_spawn_time > max(0.2, SPAWN_SEC / max(0.0001, settings.get('spawn_multiplier',1))):\r\n        spawn_enemy()\r\n        last_spawn_time = time.time()\r\n\r\n    # update fireballs\r\n    for fb in list(fireballs):\r\n        ent = fb['ent']\r\n        ent.position += fb['vel'] * dt\r\n        # lifetime\r\n        if time.time() - fb['born'] > 4.0:\r\n            try:\r\n                fireballs.remove(fb)\r\n            except:\r\n                pass\r\n            if len(fireball_pool) < POOL_MAX:\r\n                fb['ent'].enabled = False\r\n                fireball_pool.append(fb['ent'])\r\n            else:\r\n                destroy(fb['ent'])\r\n\r\n    # update enemies: steer toward the player's current position\r\n    for en in list(enemies):\r\n        ent = en['ent']\r\n        # vector to player\r\n        to_player = (player.position - ent.position)\r\n        if to_player.length_squared() > 0.0001:\r\n            desired_dir = to_player.normalized()\r\n            # initialize forward if missing\r\n            if 'forward' not in en:\r\n                en['forward'] = Vec3(0,0,1)\r\n            cur_fwd = en['forward']\r\n            # clamp dot product for numeric safety\r\n            dot = clamp(cur_fwd.dot(desired_dir), -1.0, 1.0)\r\n            angle = math.degrees(math.acos(dot))\r\n            max_turn = ENEMY_TURN_RATE * dt\r\n            if angle > 0.001:\r\n                t = min(1.0, max_turn / max(1e-6, angle))\r\n                new_fwd = lerp(cur_fwd, desired_dir, t).normalized()\r\n                en['forward'] = new_fwd\r\n            else:\r\n                new_fwd = cur_fwd\r\n            vel = new_fwd * en.get('speed', ENEMY_SPEED)\r\n            ent.position += vel * dt\r\n        # simple collision distance\r\n        if distance(ent.position, player.position) < 1.0:\r\n            # end game: show message\r\n            invoke(lambda: application.quit(), delay=0.1)\r\n            return\r\n        # check collisions with fireballs\r\n        for fb in list(fireballs):\r\n            if distance(ent.position, fb['ent'].position) < 1.2:\r\n                # kill\r\n                try:\r\n                    enemies.remove(en)\r\n                except:\r\n                    pass\r\n                try:\r\n                    fireballs.remove(fb)\r\n                except:\r\n                    pass\r\n                # spawn particles (simple enable/disable)\r\n                if particles_pool:\r\n                    # spawn multiple small particles with velocities\r\n                    for n in range(6):\r\n                        if not particles_pool: break\r\n                        p = particles_pool.pop()\r\n                        p.position = ent.position\r\n                        p.enabled = True\r\n                        # attach velocity and born time\r\n                        p.vel = Vec3(random.uniform(-1,1), random.uniform(0,1), random.uniform(-1,1)) * 3.0\r\n                        p.born = pytime.time()\r\n                        particles_active.append(p)\r\n                # return to pools\r\n                if len(enemy_pool) < POOL_MAX:\r\n                    ent.enabled = False\r\n                    enemy_pool.append(ent)\r\n                else:\r\n                    destroy(ent)\r\n                if len(fireball_pool) < POOL_MAX:\r\n                    fb['ent'].enabled = False\r\n                    fireball_pool.append(fb['ent'])\r\n                else:\r\n                    destroy(fb['ent'])\r\n                score += 1\r\n                score_text.text = f'Kills: {score}'\r\n                # play kill sound\r\n                if settings.get('sound', True):\r\n                    if kill_snd:\r\n                        try: kill_snd.play()\r\n                        except: pass\r\n                    elif winsound:\r\n                        try: winsound.Beep(540, 80)\r\n                        except: pass\r\n                break\r\n        # remove if close to origin\r\n        if ent.position.length() < 0.1:\r\n            try:\r\n                enemies.remove(en)\r\n            except:\r\n                pass\r\n            if len(enemy_pool) < POOL_MAX:\r\n                ent.enabled = False\r\n                enemy_pool.append(ent)\r\n            else:\r\n                destroy(ent)\r\n\r\n    # fps display\r\n    fps_text.text = f'FPS: {int(1/max(1e-6, dt))} • Enemies: {len(enemies)}'\r\n\r\n    # adaptive spawn: sample FPS once per second\r\n    global _fps_accum, _fps_count, _last_fps_check\r\n    _fps_accum += (1.0 / max(1e-6, dt))\r\n    _fps_count += 1\r\n    now = pytime.time()\r\n    if now - _last_fps_check > 1.0:\r\n        avg_fps = _fps_accum / max(1, _fps_count)\r\n        _fps_accum = 0.0; _fps_count = 0; _last_fps_check = now\r\n        # if avg fps drops below 30, conservative throttle\r\n        if avg_fps < 30:\r\n            settings['_adaptive'] = min(4.0, settings.get('_adaptive', 1.0) * 1.15)\r\n            settings['spawn_multiplier'] = max(0.2, settings.get('spawn_multiplier',1.0) / settings['_adaptive'])\r\n            # restart spawn interval\r\n            # note: last_spawn_time reset to avoid immediate spawn\r\n            last_spawn_time = now\r\n        elif avg_fps > 45 and settings.get('_adaptive',1.0) > 1.01:\r\n            settings['_adaptive'] = max(1.0, settings.get('_adaptive',1.0) / 1.15)\r\n            settings['spawn_multiplier'] = min(2.0, settings.get('spawn_multiplier',1.0) / settings.get('_adaptive',1.0))\r\n            last_spawn_time = now\r\n\r\n    # periodic save\r\n    save_timer += dt\r\n    if save_timer > 3.0:\r\n        save_timer = 0\r\n        json.dump(settings, open(SETTINGS_FILE, 'w'))\r\n\r\n    # update particles with simple physics\r\n    for p in list(particles_active):\r\n        t = pytime.time() - p.born\r\n        p.position += p.vel * dt\r\n        p.vel *= 0.92\r\n        if t > 0.6:\r\n            try:\r\n                particles_active.remove(p)\r\n            except:\r\n                pass\r\n            p.enabled = False\r\n            if len(particles_pool) < 200:\r\n                particles_pool.append(p)\r\n            else:\r\n                destroy(p)\r\n\r\n# mouse handling: simple pointer lock and right-click free-look\r\ndef input(key):\r\n    # central input handler: shooting, pool controls, and free-look/mouse lock\r\n    global free_look, right_mouse_look\r\n    if key == 'left mouse down' or key == 'space':\r\n        shoot()\r\n    if key == 'p':\r\n        prefill_pools()\r\n    if key == 't':\r\n        trim_pools()\r\n    if key == 'f':\r\n        # toggle free-look + lock pointer when enabled\r\n        free_look = not free_look\r\n        mouse.locked = bool(free_look)\r\n        free_look_indicator.text = 'Free Look: ' + ('ON' if free_look else 'OFF') + ' (F)'\r\n    if key == 'right mouse down':\r\n        right_mouse_look = True\r\n        mouse.locked = True\r\n    if key == 'right mouse up':\r\n        right_mouse_look = False\r\n        # only unlock if free_look is not active\r\n        if not free_look:\r\n            mouse.locked = False\r\n\r\ndef update_camera_rotation():\r\n    # rotate camera by mouse delta when free-look or right mouse held\r\n    if mouse.locked or free_look:\r\n        dx = mouse.velocity[0]\r\n        dy = mouse.velocity[1]\r\n        sensitivity = MOUSE_SENS\r\n        # apply rotation with smoothing factor\r\n        camera.rotation_y += dx * sensitivity * time.dt * (MOUSE_SMOOTH * time.dt + 1.0)\r\n        camera.rotation_x -= dy * sensitivity * time.dt * (MOUSE_SMOOTH * time.dt + 1.0)\r\n        camera.rotation_x = clamp(camera.rotation_x, -70, 70)\r\n    # relax weapon recoil back to resting position\r\n    weapon.position = weapon.position * 0.85 + Vec3(0.28, -0.18, 0.6) * 0.15\r\n\r\n# call camera rotation each frame\r\nold_update = update\r\ndef _update_wrapper():\r\n    old_update()\r\n    update_camera_rotation()\r\nglobals()['update'] = _update_wrapper\r\n\r\ndef verify_pools():\r\n    # quick sanity check: count pool sizes and display via flash\r\n    total = len(enemy_pool) + len(fireball_pool) + len(particles_pool)\r\n    print(f'Pools: enemies={len(enemy_pool)} fireballs={len(fireball_pool)} particles={len(particles_pool)} total={total}')\r\n    flash(0.4)\r\n\r\n# prefill a bit\r\nprefill_pools()\r\n\r\nif __name__ == '__main__':\r\n    app.run()\r\n","size_bytes":18421},"main.py":{"content":"def main():\n    print(\"Hello from repl-nix-workspace!\")\n\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":96}},"version":2}