<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Red Void — Minimal 3D Survival</title>
<style>
  html,body { height:100%; margin:0; background:black; overflow:hidden; font-family: Arial, sans-serif; }
  #ui {
    position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
    color: #fff; text-align:center; pointer-events:none;
  }
  #score { font-size: 20px; letter-spacing: 1px; }
  #message {
    position: absolute; top: 40%; left: 50%; transform: translate(-50%,-50%);
    color: #ff3333; font-size: 28px; display:none; text-align:center; 
  }
  #controls {
    position: absolute; bottom: 12px; left: 12px; color:#aaa; font-size:12px;
    background: rgba(0,0,0,0.4); padding:8px; border-radius:6px;
  }
  canvas { display:block; }
  #fps { position: absolute; top:12px; right:12px; color:#aaa; font-size:12px; }
  #joystick {
    position: absolute;
    left: 40px;
    bottom: 40px;
    width: 120px;
    height: 120px;
    background: rgba(255,255,255,0.1);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 60px;
    touch-action: none;
    display: none;
  }
  #joystick-knob {
    position: absolute;
    width: 50px;
    height: 50px;
    background: rgba(255,40,40,0.3);
    border: 2px solid rgba(255,40,40,0.4);
    border-radius: 25px;
    top: 35px;
    left: 35px;
    touch-action: none;
  }
</style>
</head>
<body>
<div id="ui"><div id="score">Kills: 0</div></div>
<div id="message">
  <div style="font-weight:700">You have been consumed by the void.</div>
  <div id="final">Enemies killed: 0</div>
  <div style="margin-top:12px; font-size:14px; color:#ccc; cursor:pointer;" id="restart">Click to Restart</div>
</div>
<div id="controls">
  WASD / Arrow Keys: move &nbsp; • &nbsp; Mouse: look around (360° free look) &nbsp; • &nbsp; Left Click: shoot &nbsp; • &nbsp; ESC: exit pointer lock
</div>
<div id="fps"></div>
<div id="joystick"><div id="joystick-knob"></div></div>

<!-- three.js from CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
/* === Configuration (tweak if needed) === */
const SPAWN_SEC = 1.5;       // faster spawn rate for more action
const MAX_ENEMIES = 200;     // reduced for mobile performance
// velocities are now in units-per-second
const ENEMY_SPEED = 4.0;     // increased enemy speed
const FIREBALL_SPEED = 200;  // adjusted projectile speed
const PLAYER_SPEED = 5.0;    // increased player speed
const PLAYER_RADIUS = 0.35;  // player collision radius
const ENEMY_RADIUS = 0.6;    // larger enemy radius for better visibility
const MOBILE_SCALE = 1.5;    // scale factor for mobile enemies to make them more visible
const WORLD_RADIUS = 30;     // how far enemies spawn away
/* ====================================== */

/* Basic three.js setup */
let scene, camera, renderer, clock;
let playerMesh;
let enemies = [];
let fireballs = [];
// simple object pools to reduce GC and allocations
let enemyPool = [];
let fireballPool = [];
const POOL_MAX = 300; // max pooled objects
let score = 0;
let running = true;
let spawnTimer = null;
let lastSpawn = performance.now();
let keys = {};
let pointerLocked = false;
let aimVector = new THREE.Vector3(0,0,-1);
// free look state: toggle with 'F' or hold right mouse button
let freeLook = false;
let rightMouseLook = false;
let playerYaw = 0;
let fpsMeter = document.getElementById('fps');

// free look indicator
const freeLookIndicator = document.createElement('div');
freeLookIndicator.style.position = 'absolute';
freeLookIndicator.style.left = '12px';
freeLookIndicator.style.bottom = '12px';
freeLookIndicator.style.color = '#faa';
freeLookIndicator.style.fontSize = '12px';
freeLookIndicator.style.padding = '6px 8px';
freeLookIndicator.style.background = 'rgba(0,0,0,0.4)';
freeLookIndicator.style.borderRadius = '6px';
freeLookIndicator.innerText = 'First-Person Mode (Always Active)';
freeLookIndicator.style.color = '#6f6';
document.body.appendChild(freeLookIndicator);

// Settings and persistence - moved here before init()
const SETTINGS_KEY = 'red_void_settings_v1';
let settings = {
  shadows: true,
  particles: true,
  sound: true,
  spawnMultiplier: 1.0,
  enemySpeedMultiplier: 1.0,
};
function loadSettings(){
  try { const s = JSON.parse(localStorage.getItem(SETTINGS_KEY) || 'null'); if (s) Object.assign(settings, s); } catch(e){}
}
function saveSettings(){ localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings)); }
loadSettings();

// Audio and FPS tracking - moved here before init()
let audioCtx = null;
let lastFPS = performance.now(), frames = 0;

init();
animate();

function init(){
  // scene + renderer
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  
  // Check if running on mobile
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // Force mobile mode for testing if needed
  // const isMobile = true;
  
  // Configure renderer with mobile-optimized settings
  renderer = new THREE.WebGLRenderer({ 
    antialias: false, // disable antialiasing for better performance
    alpha: false,
    powerPreference: "high-performance",
    stencil: false,
    depth: true,
    preserveDrawingBuffer: true,
    precision: isMobile ? "mediump" : "highp" // use medium precision on mobile
  });
  
  // Force WebGL1 for better compatibility
  renderer.getContext().getExtension('WEBGL_lose_context');
  
  // Disable some effects on mobile for performance
  if (isMobile) {
    THREE.Object3D.DefaultMatrixAutoUpdate = false;
    THREE.Object3D.DefaultUp.set(0, 1, 0);
  }
  
  // Force renderer context attributes for better compatibility
  renderer.getContext().getContextAttributes().premultipliedAlpha = true;
  renderer.getContext().getContextAttributes().preserveDrawingBuffer = true;
  
  // Ensure renderer is properly configured
  renderer.setClearColor(0x000000, 1);
  renderer.setPixelRatio(window.devicePixelRatio);
  
  // Basic fog for performance
  scene.fog = new THREE.Fog(0x000000, 1, 50);
  
  // Mobile-specific optimizations
  if (isMobile) {
    renderer.setPixelRatio(1); // force lower resolution for better performance
    renderer.shadowMap.enabled = false;
    
    // Reduce visual effects on mobile
    settings.particles = false;
    settings.shadows = false;
    
    // Adjust camera for mobile
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 40);
  } else {
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 1000);
  }
  
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  
  // Force a complete renderer reset
  renderer.dispose();
  renderer.info.reset();

  // camera (first-person view at player eye level)
  camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.7, 0);

  // Enhanced lighting for better 3D depth
  const ambient = new THREE.AmbientLight(0x0a0a0a, 0.3);
  scene.add(ambient);

  // Main directional light with stronger shadows
  const dirLight = new THREE.DirectionalLight(0xff4444, 0.4);
  dirLight.position.set(10, 15, 8);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(2048, 2048);
  dirLight.shadow.camera.near = 0.5;
  dirLight.shadow.camera.far = 100;
  scene.add(dirLight);

  // Rim light for depth
  const rim = new THREE.DirectionalLight(0x8888ff, 0.15);
  rim.position.set(-8, 6, -8);
  scene.add(rim);

  // player: invisible in first-person (camera IS the player)
  // Create a simple collision sphere for player that's invisible
  playerMesh = new THREE.Group();
  playerMesh.position.set(0, 1.7, 0);
  scene.add(playerMesh);
  
  // Add camera to player so it moves with the player
  playerMesh.add(camera);
  camera.position.set(0, 0, 0);
  
  // Add a point light that follows the player for better visibility
  const playerLight = new THREE.PointLight(0xff6666, 0.3, 20);
  playerLight.position.set(0, 0.3, 0);
  playerMesh.add(playerLight);

  // crosshair UI
  const ch = document.createElement('div');
  ch.id = 'crosshair';
  ch.style.position = 'absolute';
  ch.style.left = '50%';
  ch.style.top = '50%';
  ch.style.width = '10px';
  ch.style.height = '10px';
  ch.style.marginLeft = '-5px';
  ch.style.marginTop = '-5px';
  ch.style.border = '2px solid rgba(255,60,60,0.95)';
  ch.style.borderRadius = '2px';
  ch.style.pointerEvents = 'none';
  document.body.appendChild(ch);

  // ground: keep but hide large ground so scene looks empty beyond the local grid
  const groundGeo = new THREE.PlaneGeometry(200, 200);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.05, roughness: 1.0 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -1.21;
  ground.receiveShadow = true;
  ground.visible = false; // hide the broad ground to create blackness beyond grid
  scene.add(ground);

  // neon red square grid overlay using a canvas texture (additive blending for glow)
  // create a local neon grid that follows the player so only nearby area is visible
  let gridPlane = null;
  const GRID_WORLD_SIZE = 40; // world units of visible grid (square)
  (function createNeonGrid(){
    const size = 1024;
    const divisions = 20; // number of squares per side within the local grid
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,size,size);

    // draw glow by drawing multiple strokes with increasing thinness/alpha
    const step = size / divisions;
    for (let i = 0; i <= divisions; i++){
      const x = Math.round(i*step) + 0.5;
      const y = Math.round(i*step) + 0.5;
      // vertical glow
      for (let g = 6; g >= 1; g--) {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,40,40,${0.012 * g})`;
        ctx.lineWidth = 2 + g*1.2;
        ctx.moveTo(x, 0);
        ctx.lineTo(x, size);
        ctx.stroke();
      }
      // horizontal glow
      for (let g = 6; g >= 1; g--) {
        ctx.beginPath();
        ctx.strokeStyle = `rgba(255,40,40,${0.012 * g})`;
        ctx.lineWidth = 2 + g*1.2;
        ctx.moveTo(0, y);
        ctx.lineTo(size, y);
        ctx.stroke();
      }
    }

    const tex = new THREE.CanvasTexture(canvas);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(1,1);

  const gridMat = new THREE.MeshBasicMaterial({ 
    map: tex, 
    transparent: true, 
    blending: THREE.AdditiveBlending, 
    depthWrite: false, 
    depthTest: true,
    side: THREE.DoubleSide,
    opacity: 0.8
  });
  gridPlane = new THREE.Mesh(new THREE.PlaneGeometry(GRID_WORLD_SIZE, GRID_WORLD_SIZE), gridMat);
  gridPlane.rotation.x = -Math.PI/2;
  gridPlane.position.y = -1.19; // slightly above ground to avoid z-fighting
  gridPlane.renderOrder = 1;
  gridPlane.visible = true; // Ensure grid is visible
  scene.add(gridPlane);
  
  // Force material update
  gridMat.needsUpdate = true;
  window._redVoidGridPlane = gridPlane; // expose for debugging
  })();

  // minimal floor reference (invisible) - not needed but helps orientation
  // create a subtle red point light that flashes on spawn/kill
  window.flashLight = new THREE.PointLight(0xff0000, 0, 30);
  scene.add(window.flashLight);

  // tiny particle group for brief kill flash
  // handle window resize and input
  window.addEventListener('resize', onResize);
  window.addEventListener('keydown', e => keys[e.code] = true);
  window.addEventListener('keyup', e => keys[e.code] = false);

  // mouse controls: pointer lock to aim
  renderer.domElement.addEventListener('click', () => {
    if (!pointerLocked) renderer.domElement.requestPointerLock();
    // also allow shooting via clicks when pointer locked
  });

  document.addEventListener('pointerlockchange', () => {
    pointerLocked = !!document.pointerLockElement;
  });

  document.addEventListener('mousemove', onMouseMove);
  document.addEventListener('mousedown', onMouseDown);
  document.addEventListener('mouseup', (e) => { if (e.button === 2) rightMouseLook = false; });
  document.addEventListener('contextmenu', (e) => e.preventDefault());

  // First-person mode is always active - no need to toggle

  // drag-to-look when pointer isn't locked
  let dragging = false, lastX=0, lastY=0;
  document.addEventListener('mousedown', (e)=>{
    if (!pointerLocked && e.button === 0) { dragging = true; lastX = e.clientX; lastY = e.clientY; }
  });
  document.addEventListener('mouseup', (e)=>{ if (e.button === 0) dragging = false; });
  document.addEventListener('mouseleave', ()=> { dragging = false; });

  // help overlay on first run
  const HELP_KEY = 'red_void_seen_help_v1';
  if (!localStorage.getItem(HELP_KEY)) {
    const help = document.createElement('div');
    help.id = 'helpOverlay';
    help.style.position = 'absolute';
    help.style.left = '50%';
    help.style.top = '48%';
    help.style.transform = 'translate(-50%,-50%)';
    help.style.background = 'rgba(0,0,0,0.8)';
    help.style.color = '#fff';
    help.style.padding = '14px 18px';
    help.style.borderRadius = '8px';
    help.style.fontSize = '13px';
    help.style.textAlign = 'left';
    help.innerHTML = '<b>Controls</b><br>WASD / Arrows: move<br>Mouse: aim (pointer lock) or drag to look<br>Left click: shoot<br>Right click: hold to free look<br>F: toggle free look<br><div style="margin-top:8px; text-align:right;"><button id="helpOk">Got it</button></div>';
    document.body.appendChild(help);
    document.getElementById('helpOk').addEventListener('click', ()=>{ localStorage.setItem(HELP_KEY,'1'); help.remove(); });
  }

  // UI restart button
  document.getElementById('restart').addEventListener('click', restartGame);

  // basic touch controls (fire button)
  const fireBtn = document.createElement('div');
  fireBtn.id = 'fireBtn';
  fireBtn.style.position = 'absolute';
  fireBtn.style.right = '16px';
  fireBtn.style.bottom = '16px';
  fireBtn.style.width = '84px';
  fireBtn.style.height = '84px';
  fireBtn.style.borderRadius = '42px';
  fireBtn.style.background = 'rgba(255,40,40,0.14)';
  fireBtn.style.border = '2px solid rgba(255,40,40,0.24)';
  fireBtn.style.touchAction = 'none';
  fireBtn.style.zIndex = 9999;
  fireBtn.style.display = 'none';
  document.body.appendChild(fireBtn);
  fireBtn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); shootFireball(); });

  // Mobile controls setup
  if ('ontouchstart' in window) {
    fireBtn.style.display = 'block';
    document.getElementById('joystick').style.display = 'block';
    
    // Joystick variables
    const joystick = document.getElementById('joystick');
    const knob = document.getElementById('joystick-knob');
    let joystickActive = false;
    let joystickOffset = { x: 0, y: 0 };
    const maxOffset = 35;  // Maximum joystick movement

    // Touch handling for joystick
    joystick.addEventListener('touchstart', handleJoystickStart);
    joystick.addEventListener('touchmove', handleJoystickMove);
    joystick.addEventListener('touchend', handleJoystickEnd);

    function handleJoystickStart(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      joystickActive = true;
      updateJoystickPosition(touch.clientX - rect.left - rect.width/2, touch.clientY - rect.top - rect.height/2);
    }

    function handleJoystickMove(e) {
      if (!joystickActive) return;
      e.preventDefault();
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      updateJoystickPosition(touch.clientX - rect.left - rect.width/2, touch.clientY - rect.top - rect.height/2);
    }

    function handleJoystickEnd(e) {
      joystickActive = false;
      joystickOffset = { x: 0, y: 0 };
      knob.style.transform = `translate(0px, 0px)`;
    }

    function updateJoystickPosition(x, y) {
      const distance = Math.sqrt(x * x + y * y);
      const angle = Math.atan2(y, x);
      const clampedDistance = Math.min(distance, maxOffset);
      joystickOffset.x = (Math.cos(angle) * clampedDistance) / maxOffset;
      joystickOffset.y = (Math.sin(angle) * clampedDistance) / maxOffset;
      knob.style.transform = `translate(${joystickOffset.x * maxOffset}px, ${joystickOffset.y * maxOffset}px)`;
    }
  }

  clock = new THREE.Clock();

  // start spawning enemies at intense rate
  startSpawning();
}

/* ==== Input handlers ==== */
function onMouseMove(e){
  if (!pointerLocked) return;
  const movementX = e.movementX || 0;
  const movementY = e.movementY || 0;
  const sensitivity = 0.0024; // Slightly higher sensitivity for better control
  
  // PUBG-style: Always allow free look with mouse
  // Rotate camera (which is parented to playerMesh)
  camera.rotation.y -= movementX * sensitivity;
  camera.rotation.x -= movementY * sensitivity;
  
  // Clamp vertical rotation to prevent over-rotation
  camera.rotation.x = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, camera.rotation.x));
  
  // Update aim vector for shooting
  aimVector.set(0, 0, -1).applyQuaternion(camera.quaternion).normalize();
  
  // Player body rotates with horizontal look
  playerYaw = camera.rotation.y;
}

function onMouseDown(e){
  if (!running) return;
  if (e.button === 0) shootFireball();
  if (e.button === 2) rightMouseLook = true;
}

/* ==== Spawning ==== */
function startSpawning(){
  // clear existing timer to avoid duplicates
  if (spawnTimer) clearInterval(spawnTimer);
  const msBase = Math.max(200, Math.floor(SPAWN_SEC * 1000));
  const ms = Math.max(200, Math.floor(msBase / (settings.spawnMultiplier || 1)));
  spawnTimer = setInterval(() => {
    if (!running) return;
    if (enemies.length >= MAX_ENEMIES) return;
    spawnEnemy();
  }, ms);
}

function restartSpawningWithSettings(){
  if (spawnTimer) clearInterval(spawnTimer);
  startSpawning();
}

function spawnEnemy(){
  if (enemies.length >= MAX_ENEMIES) return; // Enforce enemy limit
  
  // Spawn enemies in a circle around player for better visibility
  const angle = Math.random() * Math.PI * 2;
  const dir = new THREE.Vector3(
    Math.cos(angle),
    0, // Keep enemies at same height as player
    Math.sin(angle)
  ).normalize();

  // Fixed spawn radius for consistency
  const pos = dir.clone().multiplyScalar(WORLD_RADIUS);
  pos.y = 1.7; // Same height as player
  
  // Larger enemies on mobile for better visibility
  const scale = isMobile ? MOBILE_SCALE : 1;
  const boxW = (1.2 + Math.random()*0.6) * scale;
  const boxH = (1.5 + Math.random()*0.8) * scale;
  const boxD = (0.6 + Math.random()*0.4) * scale;
  // try to reuse from pool
  let meshObj = null;
  if (enemyPool.length) {
    meshObj = enemyPool.pop();
    meshObj.mesh.scale.set(1,1,1);
    meshObj.mesh.visible = true;
  } else {
    const geo = new THREE.BoxGeometry(boxW, boxH, boxD);
    // Enhanced enemy appearance - more visible with stronger glow
    const mat = new THREE.MeshStandardMaterial({ 
      color: 0xff3333, 
      metalness: 0.3, 
      roughness: 0.5, 
      emissive: 0x660000,
      emissiveIntensity: 1.2
    });
    const m = new THREE.Mesh(geo, mat);
    m.castShadow = true;
    m.receiveShadow = true;
    meshObj = { mesh: m, box: new THREE.Box3() };
  }
  // configure size for pooled or new mesh
  if (meshObj && meshObj.mesh && meshObj.mesh.geometry && typeof meshObj.mesh.geometry.dispose === 'function') meshObj.mesh.geometry.dispose();
  meshObj.mesh.scale.set(1,1,1);
  meshObj.mesh.position.copy(pos);
  meshObj.mesh.lookAt(0,0,0);
  meshObj.mesh.rotation.x = 0;
  scene.add(meshObj.mesh);

    // track velocity toward player with some randomness
    const velocity = dir.clone().multiplyScalar(-1).multiplyScalar(ENEMY_SPEED * (settings.enemySpeedMultiplier || 1));

  enemies.push({ mesh: meshObj.mesh, velocity, spawnTime: performance.now(), box: meshObj.box });

  // small flash on spawn
  flash(0.6, 30);
}

// particle pool for small explosion effects
let particlePool = [];
function spawnParticles(pos, color=0xff4444){
  const count = 8;
  for (let i=0;i<count;i++){
    let p = null;
    if (particlePool.length) p = particlePool.pop();
    else {
      const g = new THREE.SphereGeometry(0.03,6,6);
      const m = new THREE.MeshBasicMaterial({ color });
      p = new THREE.Mesh(g,m);
    }
    p.position.copy(pos);
    scene.add(p);
    const vel = new THREE.Vector3((Math.random()*2-1), Math.random()*0.6, (Math.random()*2-1)).multiplyScalar(1.8);
    const born = performance.now();
    // animate manually
    const dur = 550;
    const anim = () => {
      const now = performance.now();
      const t = (now - born) / dur;
      if (t < 1) {
        p.position.addScaledVector(vel, 0.016);
        requestAnimationFrame(anim);
      } else {
        scene.remove(p);
        if (particlePool.length < 200) particlePool.push(p);
  else { if (p.geometry && typeof p.geometry.dispose === 'function') p.geometry.dispose(); if (p.material && typeof p.material.dispose === 'function') p.material.dispose(); }
      }
    };
    anim();
  }
}

// small settings UI
function createSettingsUI(){
  const panel = document.createElement('div');
  panel.style.position='absolute'; panel.style.right='12px'; panel.style.top='12px'; panel.style.background='rgba(0,0,0,0.5)'; panel.style.color='#fff'; panel.style.padding='8px'; panel.style.borderRadius='6px'; panel.style.fontSize='12px';
  panel.innerHTML = `
    <div style="margin-bottom:6px">Settings</div>
    <label><input id="s_shadows" type="checkbox"> Shadows</label><br>
    <label><input id="s_particles" type="checkbox"> Particles</label><br>
    <label><input id="s_sound" type="checkbox"> Sound</label><br>
    <label style="display:block;margin-top:6px">Spawn x <input id="s_spawn" type="range" min="0.2" max="2" step="0.1"></label>
    <label style="display:block">Enemy x <input id="s_speed" type="range" min="0.2" max="2" step="0.1"></label>
    <div style="margin-top:8px; display:flex; gap:6px;">
      <button id="prewarmPools" style="flex:1;">Pre-warm Pools</button>
      <button id="trimPools" style="flex:1;">Trim Pools</button>
    </div>
  `;
  document.body.appendChild(panel);
  document.getElementById('s_shadows').checked = settings.shadows;
  document.getElementById('s_particles').checked = settings.particles;
  document.getElementById('s_sound').checked = settings.sound;
  document.getElementById('s_spawn').value = settings.spawnMultiplier;
  document.getElementById('s_speed').value = settings.enemySpeedMultiplier;
  document.getElementById('s_shadows').addEventListener('change', (e)=>{ settings.shadows = e.target.checked; renderer.shadowMap.enabled = settings.shadows; saveSettings(); });
  document.getElementById('s_particles').addEventListener('change', (e)=>{ settings.particles = e.target.checked; saveSettings(); });
  document.getElementById('s_sound').addEventListener('change', (e)=>{ settings.sound = e.target.checked; saveSettings(); });
  document.getElementById('s_spawn').addEventListener('input', (e)=>{ settings.spawnMultiplier = parseFloat(e.target.value); saveSettings(); restartSpawningWithSettings(); });
  document.getElementById('s_speed').addEventListener('input', (e)=>{ settings.enemySpeedMultiplier = parseFloat(e.target.value); saveSettings(); });
  document.getElementById('prewarmPools').addEventListener('click', ()=>{ prewarmPools(); });
  document.getElementById('trimPools').addEventListener('click', ()=>{ trimPools(); });
}
createSettingsUI();

// prefill pools to reduce allocation spikes
function prefillPools(){
  for (let i=0;i<20;i++){
    // enemy
    if (enemyPool.length < POOL_MAX) {
      const g = new THREE.BoxGeometry(0.8,1.2,0.4);
      const m = new THREE.MeshStandardMaterial({ color: 0xff2222 });
      const mesh = new THREE.Mesh(g,m);
      mesh.castShadow = true; mesh.receiveShadow = true; mesh.visible = false;
      enemyPool.push({ mesh, box: new THREE.Box3() });
    }
    // fireball
    if (fireballPool.length < 40) {
      const g2 = new THREE.SphereGeometry(0.12,6,6);
      const m2 = new THREE.MeshBasicMaterial({ color: 0xff4444 });
      const mesh2 = new THREE.Mesh(g2,m2);
      mesh2.visible = false; fireballPool.push({ mesh: mesh2 });
    }
    // particles
    if (particlePool.length < 40) {
      const pg = new THREE.SphereGeometry(0.03,6,6);
      const pm = new THREE.MeshBasicMaterial({ color: 0xff4444 });
      const pmsh = new THREE.Mesh(pg, pm);
      pmsh.visible = false; particlePool.push(pmsh);
    }
  }
}
prefillPools();

// simple WebAudio blip for shoot/kill
function playBlip(freq=440, dur=0.08, vol=0.06){
  if (!settings.sound) return; // honor sound setting
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sawtooth';
  o.frequency.value = freq;
  g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  o.stop(audioCtx.currentTime + dur);
}

// prewarm pools more aggressively on demand
function prewarmPools(){
  // create additional items up to a safe number but not exceeding POOL_MAX
  const targetEnemies = Math.min(POOL_MAX, 120);
  const targetFireballs = Math.min(POOL_MAX, 80);
  const targetParticles = Math.min(200, 160);
  while (enemyPool.length < targetEnemies) {
    const g = new THREE.BoxGeometry(0.8,1.2,0.4);
    const m = new THREE.MeshStandardMaterial({ color: 0xff2222 });
    const mesh = new THREE.Mesh(g,m); mesh.visible = false; mesh.castShadow = true; mesh.receiveShadow = true;
    enemyPool.push({ mesh, box: new THREE.Box3() });
  }
  while (fireballPool.length < targetFireballs) {
    const g2 = new THREE.SphereGeometry(0.12,6,6);
    const m2 = new THREE.MeshBasicMaterial({ color: 0xff4444 });
    const mesh2 = new THREE.Mesh(g2,m2); mesh2.visible = false;
    fireballPool.push({ mesh: mesh2 });
  }
  while (particlePool.length < targetParticles) {
    const pg = new THREE.SphereGeometry(0.03,6,6);
    const pm = new THREE.MeshBasicMaterial({ color: 0xff4444 });
    const pmsh = new THREE.Mesh(pg, pm); pmsh.visible = false; particlePool.push(pmsh);
  }
  // small visual cue
  flash(0.6, 10);
}

// trim pools to free GPU memory when user requests it
function trimPools(){
  // leave a small reserve, but free extra
  const reserveEnemies = 40;
  while (enemyPool.length > reserveEnemies) {
    const e = enemyPool.pop();
    if (e && e.mesh) {
      if (e.mesh.geometry && typeof e.mesh.geometry.dispose === 'function') e.mesh.geometry.dispose();
      if (e.mesh.material && typeof e.mesh.material.dispose === 'function') e.mesh.material.dispose();
    }
  }
  const reserveFire = 20;
  while (fireballPool.length > reserveFire) {
    const f = fireballPool.pop();
    if (f && f.mesh) {
      if (f.mesh.geometry && typeof f.mesh.geometry.dispose === 'function') f.mesh.geometry.dispose();
      if (f.mesh.material && typeof f.mesh.material.dispose === 'function') f.mesh.material.dispose();
    }
  }
  const reserveParticles = 40;
  while (particlePool.length > reserveParticles) {
    const p = particlePool.pop();
    if (p) {
      if (p.geometry && typeof p.geometry.dispose === 'function') p.geometry.dispose();
      if (p.material && typeof p.material.dispose === 'function') p.material.dispose();
    }
  }
  // hint garbage collection by toggling a tiny flash
  flash(0.3, 8);
}

/* ==== Shooting ==== */
function shootFireball(){
  // small red sphere that moves in aimVector direction from player forward
  // reuse fireball from pool when possible
  let fb = null;
  if (fireballPool.length) {
    fb = fireballPool.pop();
    fb.mesh.visible = true;
  } else {
    const geo = new THREE.SphereGeometry(0.18, 10, 10);
    const mat = new THREE.MeshBasicMaterial({ color: 0xff6666 });
    const m = new THREE.Mesh(geo, mat);
    m.castShadow = true;
    fb = { mesh: m };
  }
  // Ensure proper fireball positioning and velocity
  const start = playerMesh.position.clone().add(new THREE.Vector3(0, 0, 0));
  start.add(aimVector.clone().multiplyScalar(PLAYER_RADIUS + 0.6));
  fb.mesh.position.copy(start);
  scene.add(fb.mesh);
  
  // Ensure proper velocity calculation
  const velocity = aimVector.clone().normalize().multiplyScalar(FIREBALL_SPEED);
  fireballs.push({ mesh: fb.mesh, velocity, born: performance.now() });

  // Enhance visual feedback
  flash(0.5, 20);
  playBlip(880, 0.06, 0.08);
}

/* ==== Flash helper (fade quickly) ==== */
function flash(intensity, distance){
  window.flashLight.intensity = intensity;
  window.flashLight.distance = distance;
  // center the light near camera for dramatic effect
  window.flashLight.position.copy(camera.position);
  setTimeout(()=> { window.flashLight.intensity = 0; }, 45);
}

/* ==== Game loop ==== */
function animate(){
  if (!running) {
    render(); // allow final frame
    return;
  }

  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  // move player via WASD (move relative to camera yaw)
  handlePlayerMovement(dt);

  // update camera: third-person slightly behind player
  updateCamera();

  // ensure local grid follows the player's x/z position so only area under player is visible
  if (window._redVoidGridPlane) {
    const gp = window._redVoidGridPlane;
    gp.position.x = playerMesh.position.x;
    gp.position.z = playerMesh.position.z;
  }

  // update fireballs
  for (let i = fireballs.length-1; i >= 0; i--){
    const f = fireballs[i];
  f.mesh.position.addScaledVector(f.velocity, dt);
    // remove old projectiles
    if (performance.now() - f.born > 4000) {
      scene.remove(f.mesh);
      // return to pool
      if (fireballPool.length < POOL_MAX) {
        fireballPool.push({ mesh: f.mesh });
        f.mesh.visible = false;
      } else {
        // fully dispose geometry/material to free GPU
        if (f.mesh && f.mesh.geometry && typeof f.mesh.geometry.dispose === 'function') f.mesh.geometry.dispose();
        if (f.mesh && f.mesh.material && typeof f.mesh.material.dispose === 'function') f.mesh.material.dispose();
      }
      fireballs.splice(i,1);
    }
  }

  // update enemies
  for (let i = enemies.length-1; i >= 0; i--){
    const e = enemies[i];
  e.mesh.position.addScaledVector(e.velocity, dt);

    // rotate slowly for effect
    e.mesh.rotateY(0.01);

    // update bounding box for box-based collision
    e.box.setFromObject(e.mesh);
    // check collision with player (sphere vs box)
    const playerSphere = new THREE.Sphere(playerMesh.position.clone(), PLAYER_RADIUS + ENEMY_RADIUS);
    if (e.box.intersectsSphere(playerSphere)) {
      endGame();
      return;
    }

    // check collisions with fireballs
    let killed = false;
    for (let j = fireballs.length-1; j >= 0; j--){
      const f = fireballs[j];
  const d = f.mesh.position.distanceTo(e.mesh.position);
  if (d < 1.2) { // increased hit threshold to make kills easier
        // kill enemy
        // remove both
          scene.remove(e.mesh);
          scene.remove(f.mesh);
    // visual pop: scale up briefly then return to pool
          const origScale = e.mesh.scale.clone();
          const targetScale = origScale.clone().multiplyScalar(1.6);
          let tStart = performance.now();
          const popDur = 120;
          const popAnim = () => {
            const now = performance.now();
            const t = Math.min(1, (now - tStart) / popDur);
            e.mesh.scale.lerpVectors(origScale, targetScale, t);
            if (t < 1) requestAnimationFrame(popAnim);
            else {
              // after pop, return to pool
              scene.remove(e.mesh);
              if (enemyPool.length < POOL_MAX) { enemyPool.push({ mesh: e.mesh, box: e.box }); e.mesh.visible = false; }
              else { if (e.mesh && e.mesh.geometry && typeof e.mesh.geometry.dispose === 'function') e.mesh.geometry.dispose(); if (e.mesh && e.mesh.material && typeof e.mesh.material.dispose === 'function') e.mesh.material.dispose(); }
              // spawn particles and sound
              spawnParticles(e.mesh.position, 0xff4444);
              playBlip(540, 0.08, 0.08);
            }
          };
          popAnim();
          // return fireball to pool immediately
          if (fireballPool.length < POOL_MAX) { fireballPool.push({ mesh: f.mesh }); f.mesh.visible = false; }
          else { if (f.mesh && f.mesh.geometry && typeof f.mesh.geometry.dispose === 'function') f.mesh.geometry.dispose(); if (f.mesh && f.mesh.material && typeof f.mesh.material.dispose === 'function') f.mesh.material.dispose(); }
          enemies.splice(i,1);
          fireballs.splice(j,1);
        // particle-like brief scale pop
        // tiny red pulse via flash
        flash(0.9, 30);
        score++;
        updateScore();
        killed = true;
        break;
      }
    }
    if (killed) continue;

    // tiny optimization: if enemy passes inside a small sphere behind player, remove
    if (e.mesh.position.length() < 0.1) {
      scene.remove(e.mesh);
      enemies.splice(i,1);
    }
  }

  render();
  updateFPS();
}

function render(){
  renderer.render(scene, camera);
}

function updateScore(){
  document.getElementById('score').innerText = 'Kills: ' + score;
}

/* ==== Player movement and camera ==== */
let velocity = new THREE.Vector3(0,0,0);
function handlePlayerMovement(dt){
  // Enhanced movement handling
  const yaw = freeLook ? playerYaw : camera.rotation.y;
  
  // Calculate movement vectors relative to camera
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, yaw, 0))).normalize();
  const right = new THREE.Vector3(1,0,0).applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(0, yaw, 0))).normalize();
  let move = new THREE.Vector3();
  
  // Store previous position for collision detection
  const previousPosition = playerMesh.position.clone();
  
  // Handle both keyboard and touch joystick input
  if (keys['KeyW'] || keys['ArrowUp'] || (joystickOffset && joystickOffset.y < -0.1)) move.add(forward);
  if (keys['KeyS'] || keys['ArrowDown'] || (joystickOffset && joystickOffset.y > 0.1)) move.sub(forward);
  if (keys['KeyA'] || keys['ArrowLeft'] || (joystickOffset && joystickOffset.x < -0.1)) move.sub(right);
  if (keys['KeyD'] || keys['ArrowRight'] || (joystickOffset && joystickOffset.x > 0.1)) move.add(right);
  if (move.length() > 0) move.normalize();
  // Apply movement to player mesh (camera follows since it's parented)
  playerMesh.position.addScaledVector(move, PLAYER_SPEED * dt);
  
  // Keep player height constant for first-person feel
  playerMesh.position.y = 1.7;
  
  // Limit movement range (keep near origin)
  const horizontalPos = new THREE.Vector2(playerMesh.position.x, playerMesh.position.z);
  if (horizontalPos.length() > 2.6) {
    horizontalPos.setLength(2.6);
    playerMesh.position.x = horizontalPos.x;
    playerMesh.position.z = horizontalPos.y;
  }
}

function updateCamera(){
  // First-person: camera is attached to playerMesh, so it moves automatically
  // No offset needed - camera IS the player's eyes
  // Camera rotation is handled by mouse input
}

/* ==== End game / Restart ==== */
function endGame(){
  running = false;
  clearInterval(spawnTimer);
  // show message
  document.getElementById('message').style.display = 'block';
  document.getElementById('final').innerText = 'Enemies killed: ' + score;
  // silence and small red flash
  flash(1.2, 40);
}

function restartGame(){
  // cleanup scene objects
  clearInterval(spawnTimer);
  enemies.forEach(e => {
    scene.remove(e.mesh);
    if (enemyPool.length < POOL_MAX) { enemyPool.push({ mesh: e.mesh, box: e.box }); e.mesh.visible = false; }
    else { if (e.mesh && e.mesh.geometry && typeof e.mesh.geometry.dispose === 'function') e.mesh.geometry.dispose(); if (e.mesh && e.mesh.material && typeof e.mesh.material.dispose === 'function') e.mesh.material.dispose(); }
  });
  fireballs.forEach(f => {
    scene.remove(f.mesh);
    if (fireballPool.length < POOL_MAX) { fireballPool.push({ mesh: f.mesh }); f.mesh.visible = false; }
    else { if (f.mesh && f.mesh.geometry && typeof f.mesh.geometry.dispose === 'function') f.mesh.geometry.dispose(); if (f.mesh && f.mesh.material && typeof f.mesh.material.dispose === 'function') f.mesh.material.dispose(); }
  });
  enemies = [];
  fireballs = [];
  score = 0;
  updateScore();
  document.getElementById('message').style.display = 'none';
  running = true;
  // reset player & camera (first-person)
  playerMesh.position.set(0, 1.7, 0);
  camera.position.set(0, 0, 0); // relative to playerMesh
  camera.rotation.set(0, 0, 0);
  startSpawning();
  clock = new THREE.Clock();
  animate();
}

/* ==== Utilities ==== */
function onResize(){
  const width = window.innerWidth;
  const height = window.innerHeight;
  
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  
  // On mobile, use a lower resolution for better performance
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
    const scale = 0.75; // Render at 75% resolution on mobile
    renderer.setSize(width * scale, height * scale);
    renderer.domElement.style.width = width + 'px';
    renderer.domElement.style.height = height + 'px';
  } else {
    renderer.setSize(width, height);
  }
}

// updateFPS: update onscreen FPS and apply a conservative adaptive spawn throttle
function updateFPS(){
  frames++;
  const now = performance.now();
  // update every 1s to avoid noisy adjustments
  if (now - lastFPS > 1000) {
    const fps = Math.round((frames*1000)/(now-lastFPS));
    // display
    if (fpsMeter) fpsMeter.innerText = fps + ' FPS • Enemies: ' + enemies.length;
    // initialize adaptive multiplier container
    if (!settings._adaptiveMultiplier) settings._adaptiveMultiplier = 1;

    // if FPS too low, gradually increase adaptive multiplier to reduce spawn frequency
    if (fps < 30) {
      const newAdj = Math.min(4, settings._adaptiveMultiplier * 1.18);
      if (newAdj > settings._adaptiveMultiplier + 0.001) {
        settings._adaptiveMultiplier = newAdj;
        // lower spawn rate by dividing spawnMultiplier
        settings.spawnMultiplier = Math.max(0.2, (settings.spawnMultiplier || 1) / settings._adaptiveMultiplier);
        restartSpawningWithSettings();
        saveSettings();
      }
    } else if (fps > 45 && settings._adaptiveMultiplier > 1.01) {
      // gradually restore
      const newAdj = Math.max(1, settings._adaptiveMultiplier / 1.18);
      if (newAdj < settings._adaptiveMultiplier - 0.001) {
        settings._adaptiveMultiplier = newAdj;
        settings.spawnMultiplier = Math.min(2, (settings.spawnMultiplier || 1) / settings._adaptiveMultiplier);
        restartSpawningWithSettings();
        saveSettings();
      }
    }

    lastFPS = now;
    frames = 0;
  }
}

function toggleFreeLook(enable){
  freeLook = enable;
  freeLookIndicator.innerText = 'Free Look: ' + (freeLook ? 'ON' : 'OFF') + ' (F)';
  // when disabling free look, smoothly align camera rotation to playerYaw
  if (!freeLook) {
    const startYaw = camera.rotation.y;
    const endYaw = playerYaw;
    const start = performance.now();
    const dur = 240;
    const anim = () => {
      const now = performance.now();
      const t = Math.min(1, (now - start)/dur);
      camera.rotation.y = startYaw + (endYaw - startYaw) * t;
      if (t < 1) requestAnimationFrame(anim);
    };
    anim();
  }
}
</script>
</body>
</html>
